{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Register for an account on academy.ehden Enroll yourself on the online courses for getting started with OHDSI-In-a-box etc.","title":"Introduction"},{"location":"OHDSI-in-a-Box/","text":"OHDSI-in-a-box Is a virtual machine, that runs on Linux (Ubuntu), it contains OHDSI tools and sample data for personal learning and training enviroments. Instructions can be found for deploying the OHDSI-in-a-box on AWS if you like. Otherwise you can request access to asmall 4GB virtual-machine hosted on the University of Dundee SharePoint","title":"What is it?"},{"location":"db_from_ohdsi_box/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); import sqlalchemy as sql import pandas as pd ngin = sql . create_engine ( 'postgresql://etldev:etldev@192.168.0.104:5432/postgres' ) cnx = ngin . connect () inspector = sql . inspect ( ngin ) def get_df ( schema , table_name ): selection = r ''' SELECT * FROM %s . %s ''' % ( schema , table_name ) return pd . read_sql ( selection , ngin ) for schema in inspector . get_schema_names (): print ( schema ) information_schema omop_vocabulary public synthea_etl synthea_omop synthea_omop_results synthea_raw for schema in inspector . get_schema_names (): print ( f '===== { schema } ===== ' ) for table in inspector . get_table_names ( schema = schema ): print ( ' \\t ' , table ) ===== information_schema ===== sql_parts sql_languages sql_features sql_implementation_info sql_packages sql_sizing sql_sizing_profiles ===== omop_vocabulary ===== concept vocabulary domain concept_class concept_relationship relationship concept_synonym concept_ancestor drug_strength ===== public ===== ===== synthea_etl ===== source_to_standard_vocab_map ===== synthea_omop ===== condition_era measurement care_site cost dose_era drug_era fact_relationship observation payer_plan_period provider metadata source_to_concept_map visit_occurrence specimen death visit_detail cdm_source condition_occurrence device_exposure drug_exposure location note note_nlp observation_period person procedure_occurrence ===== synthea_omop_results ===== dqdashboard_results achilles_analysis achilles_results_derived achilles_heel_results achilles_results achilles_results_dist ===== synthea_raw ===== allergies careplans conditions devices encounters imaging_studies immunizations observations organizations patients payer_transitions medications payers procedures providers supplies df_patients = get_df ( 'synthea_raw' , 'patients' ) df_patients .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } id birthdate deathdate ssn drivers passport prefix first last suffix ... city state county zip lat lon healthcare_expenses healthcare_coverage load_table_id load_row_id 0 d27e78f9-55c7-40ec-9922-e05d49a4c8a5 1998-04-21 2012-10-23 999-82-2767 None None None Domingo513 Maggio310 None ... Fall River Massachusetts Bristol County 02720 41.566987 -71.047715 317032.72 2258.12 patients 1 1 9983811a-1cd8-4468-90ac-cde90f6a6b23 2008-10-17 None 999-49-2108 None None None Patti584 Hane680 None ... Melrose Massachusetts Middlesex County 02176 42.457218 -71.100029 34877.84 3335.35 patients 2 2 3b877771-2916-4e03-a1df-9b656b9f9f36 1963-07-01 1969-11-17 999-74-6598 None None None Sarina640 Metz686 None ... Warren Massachusetts Worcester County 01585 42.187558 -72.205794 5817.79 0.00 patients 3 3 4773cd3e-f603-4ef7-8088-4c75bc9b5259 1910-01-10 1975-07-21 999-26-6281 S99929918 X2326739X Mr. Eddie505 Bergnaum523 None ... Topsfield Massachusetts Essex County None 42.669755 -70.948110 1494810.11 5827.68 patients 4 4 0e517b72-2d1f-47f5-be31-ebf777539755 1988-07-12 None 999-55-8595 S99987865 X65684413X Mr. Toney527 Hane680 None ... Waltham Massachusetts Middlesex County 02472 42.418380 -71.201179 696325.58 10922.02 patients 5 ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 1220 7fc69c44-b59c-4801-91ef-f378f2680b7b 1919-04-10 2008-09-18 999-58-3340 S99997252 X881694X Mrs. Pearly845 McLaughlin530 None ... Haverhill Massachusetts Essex County 01832 42.791103 -71.056032 1594169.70 204103.79 patients 1221 1221 c40558d0-31ed-4685-b518-676c66daa182 1919-04-10 2000-10-28 999-31-6022 S99979126 X47776825X Mrs. Arletha291 Ziemann98 None ... Haverhill Massachusetts Essex County None 42.795330 -71.107308 1463521.76 19584.36 patients 1222 1222 2e84e6e2-5d09-44b7-9bda-44e52e1f7b4a 1919-04-10 1990-06-24 999-39-9491 S99923441 X46487992X Mrs. Marlen929 Becker968 None ... Haverhill Massachusetts Essex County None 42.720813 -71.073197 1412238.08 11094.06 patients 1223 1223 eff80fe3-9d78-4d35-b1d5-8e99474e87d6 1934-10-29 2012-03-10 999-68-7999 S99913104 X33876402X Ms. Carmina141 Hackett68 None ... Haverhill Massachusetts Essex County 01832 42.830061 -71.100740 1595838.17 10888.12 patients 1224 1224 51c0750a-e2db-4e4f-b8d3-9e9d572dfb41 1934-10-29 None 999-97-2556 S99971181 X49554719X Mrs. Pinkie318 Heaney114 None ... Haverhill Massachusetts Essex County 01832 42.803027 -71.094824 1571421.70 24399.49 patients 1225 1225 rows \u00d7 27 columns df_patients . columns Index(['id', 'birthdate', 'deathdate', 'ssn', 'drivers', 'passport', 'prefix', 'first', 'last', 'suffix', 'maiden', 'marital', 'race', 'ethnicity', 'gender', 'birthplace', 'address', 'city', 'state', 'county', 'zip', 'lat', 'lon', 'healthcare_expenses', 'healthcare_coverage', 'load_table_id', 'load_row_id'], dtype='object') for col in df_patients . columns : series = df_patients [ col ] print ( col , series . unique () . size , series . dtype ) id 1225 object birthdate 989 object deathdate 214 object ssn 1224 object drivers 1003 object passport 952 object prefix 4 object first 1032 object last 486 object suffix 4 object maiden 258 object marital 3 object race 5 object ethnicity 2 object gender 2 object birthplace 292 object address 1225 object city 233 object state 1 object county 14 object zip 225 object lat 1225 float64 lon 1225 float64 healthcare_expenses 1225 float64 healthcare_coverage 1143 float64 load_table_id 1 object load_row_id 1225 int64 cdm = pd . read_csv ( 'CommonDataModel/OMOP_CDM_v5_3_1.csv' , sep = \",\" , encoding = 'Latin-1' ) with pd . option_context ( 'display.max_colwidth' , - 1 ): display ( cdm ) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Unnamed: 0 field required type description table schema 0 1 condition_occurrence_id Yes INTEGER A unique identifier for each Condition Occurrence event. condition_occurrence cdm 1 2 person_id Yes INTEGER A foreign key identifier to the Person who is experiencing the condition. The demographic details of that Person are stored in the PERSON table. condition_occurrence cdm 2 3 condition_concept_id Yes INTEGER A foreign key that refers to a Standard Condition Concept identifier in the Standardized Vocabularies. condition_occurrence cdm 3 4 condition_start_date Yes DATE The date when the instance of the Condition is recorded. condition_occurrence cdm 4 5 condition_start_datetime No DATETIME The date and time when the instance of the Condition is recorded. condition_occurrence cdm ... ... ... ... ... ... ... ... 402 403 vocabulary_id Yes VARCHAR(20) A unique identifier for each Vocabulary, such as ICD9CM, SNOMED, Visit. vocabulary cdm 403 404 vocabulary_name Yes VARCHAR(255) The name describing the vocabulary, for example \"International Classification of Diseases, Ninth Revision, Clinical Modification, Volume 1 and 2 (NCHS)\" etc. vocabulary cdm 404 405 vocabulary_reference Yes VARCHAR(255) External reference to documentation or available download of the about the vocabulary. vocabulary cdm 405 406 vocabulary_version No VARCHAR(255) Version of the Vocabulary as indicated in the source. vocabulary cdm 406 407 vocabulary_concept_id Yes INTEGER A foreign key that refers to a standard concept identifier in the CONCEPT table for the Vocabulary the VOCABULARY record belongs to. vocabulary cdm 407 rows \u00d7 7 columns cdm . set_index ([ 'table' , 'field' ]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Unnamed: 0 required type description schema table field condition_occurrence condition_occurrence_id 1 Yes INTEGER A unique identifier for each Condition Occurre... cdm person_id 2 Yes INTEGER A foreign key identifier to the Person who is ... cdm condition_concept_id 3 Yes INTEGER A foreign key that refers to a Standard Condit... cdm condition_start_date 4 Yes DATE The date when the instance of the Condition is... cdm condition_start_datetime 5 No DATETIME The date and time when the instance of the Con... cdm ... ... ... ... ... ... ... vocabulary vocabulary_id 403 Yes VARCHAR(20) A unique identifier for each Vocabulary, such ... cdm vocabulary_name 404 Yes VARCHAR(255) The name describing the vocabulary, for exampl... cdm vocabulary_reference 405 Yes VARCHAR(255) External reference to documentation or availab... cdm vocabulary_version 406 No VARCHAR(255) Version of the Vocabulary as indicated in the ... cdm vocabulary_concept_id 407 Yes INTEGER A foreign key that refers to a standard concep... cdm 407 rows \u00d7 5 columns","title":"Db from ohdsi box"},{"location":"explore-datasets-python/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); The virtual machine contains multiple datasets in csv files as well as stored in a postgresql server. Connecting to Postgresql \u00b6 Firstly, import the python modules we want to use.. import sqlalchemy as sql import pandas as pd import matplotlib.pyplot as plt Install python packages \u00b6 If you don't have this module installed, you can open the terminal and install via: sudo apt update sudo apt install python3-pip pip3 install sqlachemy pandas matplotlib Connect to a database \u00b6 Give the ip address of the VirtualBox, if you are running these from inside the VirtualBox there you want to just use : ip_address = 'localhost' #or 127.0.0.1 If you have exposed the VirtualBox to your local network, or even the web, then specify that IP address ip_address = '192.168.0.104' Create an engine that connects to the postgres database that runs inside the VirtualBox ngin = sql . create_engine ( f 'postgresql://etldev:etldev@ { ip_address } :5432/postgres' ) Establish a connection to it: cnx = ngin . connect () Inspecting the databases and datasets \u00b6 We can use the inspector to see what databases (schemas) are available to use inspector = sql . inspect ( ngin ) [ schema for schema in inspector . get_schema_names () ] ['information_schema', 'omop_vocabulary', 'public', 'synthea_etl', 'synthea_omop', 'synthea_omop_results', 'synthea_raw'] Picking the raw \"synthea\" data, we can see what datasets (tables) are contained within the synthea_raw database: inspector . get_table_names ( schema = 'synthea_raw' ) ['allergies', 'careplans', 'conditions', 'devices', 'encounters', 'imaging_studies', 'immunizations', 'observations', 'organizations', 'patients', 'payer_transitions', 'medications', 'payers', 'procedures', 'providers', 'supplies'] SQL to Pandas Dataframe \u00b6 Using a quick function we can load the full table into a pandas dataframe and print what is given by the first 'row' of the table. def get_df ( schema_name , table_name ): selection = r ''' SELECT * FROM %s . %s ''' % ( schema_name , table_name ) return pd . read_sql ( selection , ngin ) df_conditions = get_df ( 'synthea_raw' , 'conditions' ) df_conditions . iloc [ 0 ] start 2001-07-09 stop None patient 0e517b72-2d1f-47f5-be31-ebf777539755 encounter 6d0fcf84-4411-478f-b4e4-fba643da0e61 code 128613002 description Seizure disorder load_table_id conditions load_row_id 1 Name: 0, dtype: object Displaying a Dataframe \u00b6 By using set_index() we can organise the table a bit better to display the data for each patient. Using drop() we can remove the unnessary column load_table_id which is just conditions for all data entries. df_conditions = df_conditions . set_index ([ 'patient' , 'encounter' , 'code' ]) . drop ( 'load_table_id' , axis = 1 ) df_conditions .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } start stop description load_row_id patient encounter code 0e517b72-2d1f-47f5-be31-ebf777539755 6d0fcf84-4411-478f-b4e4-fba643da0e61 128613002 2001-07-09 None Seizure disorder 1 703151001 2001-07-09 None History of single seizure (situation) 2 9156490c-ccef-40a0-bba7-a27b4691e333 84757009 2001-09-10 None Epilepsy 3 e670e3f9-067f-43da-8444-c4d236b002ce 40055000 2006-04-02 None Chronic sinusitis (disorder) 4 4773cd3e-f603-4ef7-8088-4c75bc9b5259 def28c54-0b05-4171-99b3-2da43460d7b3 162864005 1947-03-31 None Body mass index 30+ - obesity (finding) 5 ... ... ... ... ... ... ... 51c0750a-e2db-4e4f-b8d3-9e9d572dfb41 bc44e5e2-6ae0-4e17-9074-838f5c39c3ab 68962001 2020-02-28 2020-03-29 Muscle pain (finding) 15441 57676002 2020-02-28 2020-03-29 Joint pain (finding) 15442 36955009 2020-02-28 2020-03-29 Loss of taste (finding) 15443 840544004 2020-02-28 2020-02-28 Suspected COVID-19 15444 840539006 2020-02-28 2020-03-29 COVID-19 15445 15445 rows \u00d7 4 columns Inspecting a Series \u00b6 We can look at the column (or series) for description and count the number of unique values (number of times this was a registered condition). Using head(10) we can display the top 10 ranked conditions that appear. df_conditions [ 'description' ] . value_counts () . head ( 10 ) Viral sinusitis (disorder) 1284 Suspected COVID-19 911 COVID-19 881 Fever (finding) 804 Acute viral pharyngitis (disorder) 709 Cough (finding) 622 Acute bronchitis (disorder) 580 Normal pregnancy 516 Body mass index 30+ - obesity (finding) 489 Loss of taste (finding) 440 Name: description, dtype: int64 Filtering a DataFrame \u00b6 Next, we use filter the dataframe into just two columns: the start (date) and description of the condition. We also call two additional functions: 1. pd.to_datetime() helps by converting the date from a string into an datetime object 2. sort_values() helps by ordering the column based on the date df_small = df_conditions . reset_index ()[[ 'start' , 'description' ]] df_small [ 'start' ] = pd . to_datetime ( df_small [ 'start' ]) df_small = df_small . sort_values ( 'start' ) df_small We are able to filter the to an even smaller dataframe by requiring the date of start to be from 2019 onwards df_small_from_2019 = df_small [ df_small [ 'start' ] > '2019' ] df_small_from_2019 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } start description 13354 2019-01-02 Fracture of ankle 2039 2019-01-03 Acute bronchitis (disorder) 5072 2019-01-03 Viral sinusitis (disorder) 11537 2019-01-04 Acute bronchitis (disorder) 1929 2019-01-04 Cardiac Arrest ... ... ... 7351 2020-06-11 Viral sinusitis (disorder) 5037 2020-06-11 Neuropathy due to type 2 diabetes mellitus (di... 195 2020-06-14 Normal pregnancy 14300 2020-06-14 Sprain of ankle 4220 2020-06-16 Viral sinusitis (disorder) 7253 rows \u00d7 2 columns We make a series of new dataframes by filtering based on the description df_viral = df_small_from_2019 [ df_small_from_2019 [ 'description' ] . str . contains ( 'Viral' )] df_pregnancy = df_small_from_2019 [ df_small_from_2019 [ 'description' ] . str . contains ( 'pregnancy' )] len ( df_viral ), len ( df_pregnancy ) (180, 66) Further splitting up a dataframe for COVID-19 cases into confirmed and suspected cases df_covid = df_small_from_2019 [ df_small_from_2019 [ 'description' ] . str . contains ( 'covid' , case = False )] df_suspected_covid = df_covid [ df_covid [ 'description' ] . str . contains ( 'Suspected' )] df_confirmed_covid = df_covid [ df_covid [ 'description' ] . str . contains ( 'Suspected' ) == 0 ] len ( df_covid ), len ( df_suspected_covid ), len ( df_confirmed_covid ) (1792, 911, 881) Plotting Data \u00b6 We can now use matplotlib to make histograms showing the number of cases of various filtered conditions as a function of the start date. fig , ax = plt . subplots ( 1 , figsize = ( 14 , 5 )) _ , bins , _ = ax . hist ( df_viral [ 'start' ], bins = 40 , label = 'Viral' , lw = 4 , histtype = 'step' ) ax . hist ( df_pregnancy [ 'start' ], bins = bins , label = 'Normal Pregnancy' , lw = 4 , histtype = 'step' ) ax . hist ( df_confirmed_covid [ 'start' ], bins = bins , label = 'Confirmed COVID-19' , lw = 4 , histtype = 'step' ) ax . hist ( df_suspected_covid [ 'start' ], bins = bins , label = 'Suspected COVID-19' , lw = 4 , histtype = 'step' ) ax . set_yscale ( 'log' ) ax . set_ylabel ( 'Number of cases encountered' ) ax . set_xlabel ( 'date' ) plt . legend ( loc = 'upper left' ) plt . show ();","title":"Exploring Datasets with Python"},{"location":"explore-datasets-python/#connecting-to-postgresql","text":"Firstly, import the python modules we want to use.. import sqlalchemy as sql import pandas as pd import matplotlib.pyplot as plt","title":"Connecting to Postgresql"},{"location":"explore-datasets-python/#install-python-packages","text":"If you don't have this module installed, you can open the terminal and install via: sudo apt update sudo apt install python3-pip pip3 install sqlachemy pandas matplotlib","title":"Install python packages"},{"location":"explore-datasets-python/#connect-to-a-database","text":"Give the ip address of the VirtualBox, if you are running these from inside the VirtualBox there you want to just use : ip_address = 'localhost' #or 127.0.0.1 If you have exposed the VirtualBox to your local network, or even the web, then specify that IP address ip_address = '192.168.0.104' Create an engine that connects to the postgres database that runs inside the VirtualBox ngin = sql . create_engine ( f 'postgresql://etldev:etldev@ { ip_address } :5432/postgres' ) Establish a connection to it: cnx = ngin . connect ()","title":"Connect to a database"},{"location":"explore-datasets-python/#inspecting-the-databases-and-datasets","text":"We can use the inspector to see what databases (schemas) are available to use inspector = sql . inspect ( ngin ) [ schema for schema in inspector . get_schema_names () ] ['information_schema', 'omop_vocabulary', 'public', 'synthea_etl', 'synthea_omop', 'synthea_omop_results', 'synthea_raw'] Picking the raw \"synthea\" data, we can see what datasets (tables) are contained within the synthea_raw database: inspector . get_table_names ( schema = 'synthea_raw' ) ['allergies', 'careplans', 'conditions', 'devices', 'encounters', 'imaging_studies', 'immunizations', 'observations', 'organizations', 'patients', 'payer_transitions', 'medications', 'payers', 'procedures', 'providers', 'supplies']","title":"Inspecting the databases and datasets"},{"location":"explore-datasets-python/#sql-to-pandas-dataframe","text":"Using a quick function we can load the full table into a pandas dataframe and print what is given by the first 'row' of the table. def get_df ( schema_name , table_name ): selection = r ''' SELECT * FROM %s . %s ''' % ( schema_name , table_name ) return pd . read_sql ( selection , ngin ) df_conditions = get_df ( 'synthea_raw' , 'conditions' ) df_conditions . iloc [ 0 ] start 2001-07-09 stop None patient 0e517b72-2d1f-47f5-be31-ebf777539755 encounter 6d0fcf84-4411-478f-b4e4-fba643da0e61 code 128613002 description Seizure disorder load_table_id conditions load_row_id 1 Name: 0, dtype: object","title":"SQL to Pandas Dataframe"},{"location":"explore-datasets-python/#displaying-a-dataframe","text":"By using set_index() we can organise the table a bit better to display the data for each patient. Using drop() we can remove the unnessary column load_table_id which is just conditions for all data entries. df_conditions = df_conditions . set_index ([ 'patient' , 'encounter' , 'code' ]) . drop ( 'load_table_id' , axis = 1 ) df_conditions .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } start stop description load_row_id patient encounter code 0e517b72-2d1f-47f5-be31-ebf777539755 6d0fcf84-4411-478f-b4e4-fba643da0e61 128613002 2001-07-09 None Seizure disorder 1 703151001 2001-07-09 None History of single seizure (situation) 2 9156490c-ccef-40a0-bba7-a27b4691e333 84757009 2001-09-10 None Epilepsy 3 e670e3f9-067f-43da-8444-c4d236b002ce 40055000 2006-04-02 None Chronic sinusitis (disorder) 4 4773cd3e-f603-4ef7-8088-4c75bc9b5259 def28c54-0b05-4171-99b3-2da43460d7b3 162864005 1947-03-31 None Body mass index 30+ - obesity (finding) 5 ... ... ... ... ... ... ... 51c0750a-e2db-4e4f-b8d3-9e9d572dfb41 bc44e5e2-6ae0-4e17-9074-838f5c39c3ab 68962001 2020-02-28 2020-03-29 Muscle pain (finding) 15441 57676002 2020-02-28 2020-03-29 Joint pain (finding) 15442 36955009 2020-02-28 2020-03-29 Loss of taste (finding) 15443 840544004 2020-02-28 2020-02-28 Suspected COVID-19 15444 840539006 2020-02-28 2020-03-29 COVID-19 15445 15445 rows \u00d7 4 columns","title":"Displaying a Dataframe"},{"location":"explore-datasets-python/#inspecting-a-series","text":"We can look at the column (or series) for description and count the number of unique values (number of times this was a registered condition). Using head(10) we can display the top 10 ranked conditions that appear. df_conditions [ 'description' ] . value_counts () . head ( 10 ) Viral sinusitis (disorder) 1284 Suspected COVID-19 911 COVID-19 881 Fever (finding) 804 Acute viral pharyngitis (disorder) 709 Cough (finding) 622 Acute bronchitis (disorder) 580 Normal pregnancy 516 Body mass index 30+ - obesity (finding) 489 Loss of taste (finding) 440 Name: description, dtype: int64","title":"Inspecting a Series"},{"location":"explore-datasets-python/#filtering-a-dataframe","text":"Next, we use filter the dataframe into just two columns: the start (date) and description of the condition. We also call two additional functions: 1. pd.to_datetime() helps by converting the date from a string into an datetime object 2. sort_values() helps by ordering the column based on the date df_small = df_conditions . reset_index ()[[ 'start' , 'description' ]] df_small [ 'start' ] = pd . to_datetime ( df_small [ 'start' ]) df_small = df_small . sort_values ( 'start' ) df_small We are able to filter the to an even smaller dataframe by requiring the date of start to be from 2019 onwards df_small_from_2019 = df_small [ df_small [ 'start' ] > '2019' ] df_small_from_2019 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } start description 13354 2019-01-02 Fracture of ankle 2039 2019-01-03 Acute bronchitis (disorder) 5072 2019-01-03 Viral sinusitis (disorder) 11537 2019-01-04 Acute bronchitis (disorder) 1929 2019-01-04 Cardiac Arrest ... ... ... 7351 2020-06-11 Viral sinusitis (disorder) 5037 2020-06-11 Neuropathy due to type 2 diabetes mellitus (di... 195 2020-06-14 Normal pregnancy 14300 2020-06-14 Sprain of ankle 4220 2020-06-16 Viral sinusitis (disorder) 7253 rows \u00d7 2 columns We make a series of new dataframes by filtering based on the description df_viral = df_small_from_2019 [ df_small_from_2019 [ 'description' ] . str . contains ( 'Viral' )] df_pregnancy = df_small_from_2019 [ df_small_from_2019 [ 'description' ] . str . contains ( 'pregnancy' )] len ( df_viral ), len ( df_pregnancy ) (180, 66) Further splitting up a dataframe for COVID-19 cases into confirmed and suspected cases df_covid = df_small_from_2019 [ df_small_from_2019 [ 'description' ] . str . contains ( 'covid' , case = False )] df_suspected_covid = df_covid [ df_covid [ 'description' ] . str . contains ( 'Suspected' )] df_confirmed_covid = df_covid [ df_covid [ 'description' ] . str . contains ( 'Suspected' ) == 0 ] len ( df_covid ), len ( df_suspected_covid ), len ( df_confirmed_covid ) (1792, 911, 881)","title":"Filtering a DataFrame"},{"location":"explore-datasets-python/#plotting-data","text":"We can now use matplotlib to make histograms showing the number of cases of various filtered conditions as a function of the start date. fig , ax = plt . subplots ( 1 , figsize = ( 14 , 5 )) _ , bins , _ = ax . hist ( df_viral [ 'start' ], bins = 40 , label = 'Viral' , lw = 4 , histtype = 'step' ) ax . hist ( df_pregnancy [ 'start' ], bins = bins , label = 'Normal Pregnancy' , lw = 4 , histtype = 'step' ) ax . hist ( df_confirmed_covid [ 'start' ], bins = bins , label = 'Confirmed COVID-19' , lw = 4 , histtype = 'step' ) ax . hist ( df_suspected_covid [ 'start' ], bins = bins , label = 'Suspected COVID-19' , lw = 4 , histtype = 'step' ) ax . set_yscale ( 'log' ) ax . set_ylabel ( 'Number of cases encountered' ) ax . set_xlabel ( 'date' ) plt . legend ( loc = 'upper left' ) plt . show ();","title":"Plotting Data"},{"location":"install-OHDSI-in-a-Box/","text":"To setup OHDSI-in-a-Box you will need the following: Oracle VirtualBox Manager installed and running on your system. omopdemo.ova file from the University of Dundee SharePoint It's recommended to extract the raw omopdemo-disk001.vmdk file and use this in the installation. .ova files are effectively zip files and can be extracted with tools like 7-Zip Once you have these you can run the VirtualBox Manager and create a new virtual machine by clicking New and following the installation instructions. Requesting at least 4GB of memory would be recommended.","title":"Install"},{"location":"white-rabbit/","text":"is shit","title":"WhiteRabbit"}]}